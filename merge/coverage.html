
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>merge: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mariotoffia/godeviceshadow/merge/desired.go (78.2%)</option>
				
				<option value="file1">github.com/mariotoffia/godeviceshadow/merge/logger.go (75.0%)</option>
				
				<option value="file2">github.com/mariotoffia/godeviceshadow/merge/merge.go (85.3%)</option>
				
				<option value="file3">github.com/mariotoffia/godeviceshadow/merge/notify.go (68.8%)</option>
				
				<option value="file4">github.com/mariotoffia/godeviceshadow/merge/utils.go (72.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package merge

import (
        "fmt"
        "reflect"

        "github.com/mariotoffia/godeviceshadow/utils/vtsutils"
)

// DesiredOptions holds configuration such as `MergeLoggers`.
type DesiredOptions struct {
        // Loggers will be notified on add, updated, remove, not-changed operations while merging.
        Loggers DesiredLoggers
}

type DesiredObject struct {
        DesiredOptions
        CurrentPath string
}

// Desired is a special merge where a report model is analyses if it matches the desired model. All matched
// are removed or set to `nil` in the desired model. The result is the desired model with the changes.
//
// It will only merge `model.ValueAndTimestamp` where `model.ValueAndTimestamp.GetValue()` are equal in
// the reported model. When that happens, it will remove the value from the desired model and report
// to `DesiredOptions.DesiredLoggers`.
func Desired[T any](reportedModel, desiredModel T, opts DesiredOptions) (T, error) <span class="cov8" title="1">{
        //
        mergedVal, err := DesiredAny(reportedModel, desiredModel, opts)

        var zero T

        if err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>

        <span class="cov8" title="1">return mergedVal.(T), nil</span>
}

func DesiredAny(reportedModel, desiredModel any, opts DesiredOptions) (any, error) <span class="cov8" title="1">{
        //
        reportedVal := reflect.ValueOf(reportedModel)
        desiredVal := reflect.ValueOf(desiredModel)

        if reportedVal.Kind() != desiredVal.Kind() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reported and desired model must be of the same kind: %s != %s", reportedVal.Kind(), desiredVal.Kind())
        }</span>

        <span class="cov8" title="1">return desiredRecursive(reportedVal, desiredVal, DesiredObject{DesiredOptions: opts}).Interface(), nil</span>
}

func desiredRecursive(reportedVal, desiredVal reflect.Value, obj DesiredObject) reflect.Value <span class="cov8" title="1">{
        if !reportedVal.IsValid() || !desiredVal.IsValid() </span><span class="cov0" title="0">{
                return reflect.Value{}
        }</span>

        // Only check IsNil for types where it is valid
        <span class="cov8" title="1">if (reportedVal.Kind() == reflect.Ptr || reportedVal.Kind() == reflect.Interface) &amp;&amp; reportedVal.IsNil() </span><span class="cov8" title="1">{
                return reflect.Value{}
        }</span>
        <span class="cov8" title="1">if (desiredVal.Kind() == reflect.Ptr || desiredVal.Kind() == reflect.Interface) &amp;&amp; desiredVal.IsNil() </span><span class="cov8" title="1">{
                return reflect.Value{}
        }</span>

        <span class="cov8" title="1">if !desiredVal.CanSet() </span><span class="cov8" title="1">{
                // If desiredVal is not addressable, create a new addressable copy
                desiredVal = makeAddressable(desiredVal)
        }</span>

        <span class="cov8" title="1">if rvt, ok := unwrapValueAndTimestamp(reportedVal); ok </span><span class="cov8" title="1">{
                if dvt, ok := unwrapValueAndTimestamp(desiredVal); ok &amp;&amp; vtsutils.Equals(rvt, dvt) </span><span class="cov8" title="1">{
                        obj.Loggers.NotifyAcknowledge(obj.CurrentPath, rvt)

                        // Remove from desired model
                        return reflect.Zero(desiredVal.Type())
                }</span>

                <span class="cov8" title="1">return desiredVal</span>
        }

        <span class="cov8" title="1">reportedVal = unwrapReflectValue(reportedVal)
        basePath := obj.CurrentPath

        switch reportedVal.Kind() </span>{
        case reflect.Struct:<span class="cov8" title="1">
                for i := 0; i &lt; reportedVal.NumField(); i++ </span><span class="cov8" title="1">{
                        field := reportedVal.Type().Field(i)

                        if field.PkgPath != "" </span><span class="cov8" title="1">{
                                continue</span> // Unexported field -&gt; skip
                        }

                        <span class="cov8" title="1">tag := getJSONTag(field)

                        if tag == "" </span><span class="cov0" title="0">{
                                continue</span> // No tag -&gt; skip
                        }

                        <span class="cov8" title="1">obj.CurrentPath = concatPath(basePath, tag)

                        if r := desiredRecursive(reportedVal.Field(i), desiredVal.Field(i), obj); r.IsValid() </span><span class="cov8" title="1">{
                                desiredVal.Field(i).Set(r)
                        }</span>
                }
        case reflect.Map:<span class="cov8" title="1">
                for _, key := range reportedVal.MapKeys() </span><span class="cov8" title="1">{
                        obj.CurrentPath = concatPath(basePath, formatKey(key))

                        result := desiredRecursive(reportedVal.MapIndex(key), desiredVal.MapIndex(key), obj)

                        if result.IsValid() &amp;&amp; !result.IsZero() </span><span class="cov8" title="1">{
                                // Update key with the new value
                                desiredVal.SetMapIndex(key, result)
                        }</span> else<span class="cov8" title="1"> {
                                // Remove key from the map
                                desiredVal.SetMapIndex(key, reflect.Value{}) // This deletes the key
                        }</span>
                }
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                // This makes no sense - we need to introduce a `model.ValueIDAndTimeStamp` to match ID
                // as we do in a map. Do not use slices/arrays!
                minLen := reportedVal.Len()

                if minLen &gt; desiredVal.Len() </span><span class="cov0" title="0">{
                        minLen = desiredVal.Len()
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; minLen; i++ </span><span class="cov0" title="0">{
                        obj.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)

                        if r := desiredRecursive(reportedVal.Index(i), desiredVal.Index(i), obj); r.IsValid() </span><span class="cov0" title="0">{
                                desiredVal.Index(i).Set(r)
                        }</span>
                }
        }

        <span class="cov8" title="1">return desiredVal</span>
}

func makeAddressable(v reflect.Value) reflect.Value <span class="cov8" title="1">{
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov8" title="1">ptr := reflect.New(v.Type())
        ptr.Elem().Set(v)
        return ptr.Elem()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package merge

import (
        "time"

        "github.com/mariotoffia/godeviceshadow/model"
)

// MergeLoggers is a slice of MergeLogger.
type MergeLoggers []model.MergeLogger

// DesiredLoggers is a slice of DesiredLogger.
type DesiredLoggers []model.DesiredLogger

func (dl DesiredLoggers) NotifyAcknowledge(path string, value model.ValueAndTimestamp) <span class="cov8" title="1">{
        for _, l := range dl </span><span class="cov8" title="1">{
                l.Acknowledge(path, value)
        }</span>
}

func (ml MergeLoggers) NotifyPrepare() error <span class="cov8" title="1">{
        for _, l := range ml </span><span class="cov8" title="1">{
                if p, ok := l.(model.MergeLoggerPrepare); ok </span><span class="cov0" title="0">{
                        if err := p.Prepare(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (ml MergeLoggers) NotifyPost(err error) error <span class="cov8" title="1">{
        for _, l := range ml </span><span class="cov8" title="1">{
                if p, ok := l.(model.MergeLoggerPost); ok </span><span class="cov0" title="0">{
                        if err := p.Post(err); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (ml MergeLoggers) NotifyManaged(
        path string,
        operation model.MergeOperation,
        oldValue, newValue model.ValueAndTimestamp,
        oldTimeStamp, newTimeStamp time.Time,
) <span class="cov8" title="1">{
        for _, l := range ml </span><span class="cov8" title="1">{
                l.Managed(path, operation, oldValue, newValue, oldTimeStamp, newTimeStamp)
        }</span>
}

func (ml MergeLoggers) NotifyPlain(
        path string,
        operation model.MergeOperation,
        oldValue, newValue any,
) <span class="cov8" title="1">{
        for _, l := range ml </span><span class="cov8" title="1">{
                l.Plain(path, operation, oldValue, newValue)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package merge

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/mariotoffia/godeviceshadow/model"
)

// MergeMode indicates how merging is done regarding deletions.
// This is a duplicate of model.MergeMode to maintain backward compatibility.
type MergeMode = model.MergeMode

const (
        // ClientIsMaster is when a client is considered the master
        // and deletions are propagated.
        ClientIsMaster MergeMode = model.ClientIsMaster
        // ServerIsMaster, only updates and additions are propagated.
        ServerIsMaster MergeMode = model.ServerIsMaster
)

// MergeOptions holds configuration for how the merge should be performed.
type MergeOptions struct {
        // Mode specified how the merge should be performed regarding deletions.
        Mode MergeMode
        // DoOverrideWithEmpty when set to `true` it will check if the override value is "empty"
        // i.e. zero value zero len array, map, slice, nil pointer, etc. If it is `true` and the
        // override value is "empty" it will override the base value. If set to `false` it will
        // keep the base value.
        DoOverrideWithEmpty bool
        // MergeSlicesByID when set to `true`, it will attempt to merge slices by matching elements
        // with the same ID (requires elements to implement IdValueAndTimestamp). When `false` or
        // when elements don't implement IdValueAndTimestamp, slices are merged by position.
        MergeSlicesByID bool
        // Loggers will be notified on add, updated, remove, not-changed operations while merging.
        Loggers MergeLoggers
}

type MergeObject struct {
        MergeOptions
        CurrentPath string
}

// Merge merges newModel into oldModel following the specified rules:
//
//  1. If the type implements the Merger interface, its custom Merge method is used.
//
//  2. If a field implements ValueAndTimestamp or IdValueAndTimestamp:
//     - Compare timestamps. The newer timestamp wins.
//     - If Mode=ClientIsMaster and field missing in newModel, remove from merged result.
//     - If Mode=ServerIsMaster and field missing in newModel, keep from oldModel.
//     - If timestamps are equal =&gt; no update (keep old).
//
//  3. For slices/arrays with elements implementing IdValueAndTimestamp and MergeSlicesByID=true:
//     - Elements are matched by ID instead of by position.
//     - Elements with the same ID are merged recursively.
//     - New elements in newModel are added.
//     - Elements only in oldModel are kept if ServerIsMaster, removed if ClientIsMaster.
//
//  4. If a field does not implement ValueAndTimestamp:
//     - Overwrite from newModel if present.
//     - If absent in newModel: remove if ClientIsMaster, keep if ServerIsMaster.
//
// Returns the merged model. Neither _oldModel_ nor _newModel_ is modified.
func Merge[T any](oldModel, newModel T, opts MergeOptions) (T, error) <span class="cov8" title="1">{

        mergedVal, err := MergeAny(oldModel, newModel, opts)

        var zero T

        if err != nil </span><span class="cov8" title="1">{
                return zero, err
        }</span>

        <span class="cov8" title="1">return mergedVal.(T), nil</span>
}

func MergeAny(oldModel, newModel any, opts MergeOptions) (any, error) <span class="cov8" title="1">{
        //
        oldVal := reflect.ValueOf(oldModel)
        newVal := reflect.ValueOf(newModel)

        if oldVal.Kind() != newVal.Kind() </span><span class="cov8" title="1">{
                return oldModel, fmt.Errorf("oldModel: '%T' and newModel: '%T' must be of the same type", oldModel, newModel)
        }</span>

        <span class="cov8" title="1">if err := opts.Loggers.NotifyPrepare(); err != nil </span><span class="cov0" title="0">{
                return oldModel, err
        }</span>

        <span class="cov8" title="1">mergedVal, err := mergeRecursive(oldVal, newVal, MergeObject{MergeOptions: opts})

        if err2 := opts.Loggers.NotifyPost(err); err2 != nil </span><span class="cov0" title="0">{
                return oldModel, err2
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return oldModel, err
        }</span>

        <span class="cov8" title="1">return mergedVal.Interface(), nil</span>
}

// mergeRecursive will try to merge base with override recursively.
func mergeRecursive(base, override reflect.Value, obj MergeObject) (reflect.Value, error) <span class="cov8" title="1">{
        if !override.IsValid() </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("both base: '%T' and override: '%T' must be valid", base.Interface(), override.Interface())
        }</span>

        // Check for Merger interface before unwrapping
        <span class="cov8" title="1">if merger, ok := base.Interface().(model.Merger); ok </span><span class="cov8" title="1">{
                result, err := merger.Merge(override.Interface(), model.MergeMode(obj.Mode))
                if err != nil </span><span class="cov8" title="1">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov8" title="1">return reflect.ValueOf(result), nil</span>
        }

        <span class="cov8" title="1">baseVal := base
        overrideVal := override

        // If either is an interface, unwrap to get the concrete type.
        if base.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                baseVal = base.Elem()
        }</span>

        <span class="cov8" title="1">if override.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                overrideVal = override.Elem()
        }</span>

        // is pointer -&gt; unwrap to the element (unless nil)
        <span class="cov8" title="1">if baseVal.Kind() == reflect.Ptr &amp;&amp; !baseVal.IsNil() </span><span class="cov8" title="1">{
                baseVal = baseVal.Elem()
        }</span>

        <span class="cov8" title="1">if overrideVal.Kind() == reflect.Ptr &amp;&amp; !overrideVal.IsNil() </span><span class="cov8" title="1">{
                overrideVal = overrideVal.Elem()
        }</span>

        // implements ValueAndTimestamp -&gt; handle timestamped merge
        <span class="cov8" title="1">baseValTS, baseOk := unwrapValueAndTimestamp(baseVal)
        overrideValTS, overrideOk := unwrapValueAndTimestamp(overrideVal)

        if baseOk &amp;&amp; overrideOk </span><span class="cov8" title="1">{
                oldTS := baseValTS.GetTimestamp()
                newTS := overrideValTS.GetTimestamp()

                switch </span>{
                case newTS.After(oldTS):<span class="cov8" title="1">
                        obj.Loggers.NotifyManaged(obj.CurrentPath, model.MergeOperationUpdate, baseValTS, overrideValTS, oldTS, newTS)

                        return override, nil</span> // override newer -&gt; replace
                default:<span class="cov8" title="1">
                        obj.Loggers.NotifyManaged(obj.CurrentPath, model.MergeOperationNotChanged, baseValTS, overrideValTS, oldTS, newTS)

                        return base, nil</span> // override less or equal -&gt; no update -&gt; keep old
                }
        }

        <span class="cov8" title="1">switch baseVal.Kind() </span>{
        case reflect.Struct:<span class="cov8" title="1">
                return mergeStruct(baseVal, overrideVal, obj)</span>
        case reflect.Map:<span class="cov8" title="1">
                return mergeMap(baseVal, overrideVal, obj)</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                return mergeSlice(baseVal, overrideVal, obj)</span>
        // Basic types (int, string, ...)
        default:<span class="cov8" title="1">
                if obj.Mode == ServerIsMaster </span><span class="cov8" title="1">{
                        if isEmptyValue(overrideVal) </span><span class="cov0" title="0">{
                                obj.Loggers.NotifyPlain(obj.CurrentPath, model.MergeOperationNotChanged, baseVal.Interface(), overrideVal.Interface())

                                return base, nil
                        }</span>
                }

                <span class="cov8" title="1">if obj.DoOverrideWithEmpty &amp;&amp; isEmptyValue(overrideVal) </span><span class="cov0" title="0">{
                        return override, nil
                }</span>

                <span class="cov8" title="1">bv := baseVal.Interface()
                ov := overrideVal.Interface()

                if bv != ov </span><span class="cov8" title="1">{
                        obj.Loggers.NotifyPlain(obj.CurrentPath, model.MergeOperationUpdate, bv, ov)

                        return override, nil // not equal -&gt; override
                }</span> else<span class="cov8" title="1"> {
                        obj.Loggers.NotifyPlain(obj.CurrentPath, model.MergeOperationNotChanged, bv, ov)

                        return base, nil // equal -&gt; keep old
                }</span>
        }
}

func mergeSlice(baseVal, overrideVal reflect.Value, opts MergeObject) (reflect.Value, error) <span class="cov8" title="1">{
        if baseVal.IsNil() </span><span class="cov8" title="1">{
                notifyRecursive(overrideVal, model.MergeOperationAdd, opts)

                return overrideVal, nil
        }</span>

        <span class="cov8" title="1">basePath := opts.CurrentPath

        // override is nil -&gt; remove or keep
        if overrideVal.IsNil() </span><span class="cov8" title="1">{
                switch opts.Mode </span>{
                case ClientIsMaster:<span class="cov8" title="1">
                        for i := 0; i &lt; baseVal.Len(); i++ </span><span class="cov0" title="0">{
                                opts.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)

                                notifyRecursive(baseVal.Index(i), model.MergeOperationRemove, opts)
                        }</span>
                        <span class="cov8" title="1">return overrideVal, nil</span>
                case ServerIsMaster:<span class="cov8" title="1">
                        for i := 0; i &lt; baseVal.Len(); i++ </span><span class="cov0" title="0">{
                                opts.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)

                                notifyRecursive(baseVal.Index(i), model.MergeOperationNotChanged, opts)
                        }</span>
                        <span class="cov8" title="1">return baseVal, nil</span>
                }
        }

        // If MergeSlicesByID is enabled, try to merge by ID
        <span class="cov8" title="1">if opts.MergeSlicesByID </span><span class="cov8" title="1">{
                return mergeSliceByID(baseVal, overrideVal, opts)
        }</span>

        // Otherwise, fall back to positional merge
        <span class="cov8" title="1">return mergeSliceByPosition(baseVal, overrideVal, opts)</span>
}

// mergeStruct merges two struct values (non-timestamped case).
func mergeStruct(baseVal, overrideVal reflect.Value, opts MergeObject) (reflect.Value, error) <span class="cov8" title="1">{
        if !baseVal.IsValid() || !overrideVal.IsValid() </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("both base: '%T' and override: '%T' must be valid", baseVal.Interface(), overrideVal.Interface())
        }</span>

        <span class="cov8" title="1">result := reflect.New(baseVal.Type()).Elem()
        numFields := baseVal.NumField()
        basePath := opts.CurrentPath

        for i := 0; i &lt; numFields; i++ </span><span class="cov8" title="1">{
                fieldValue := baseVal.Field(i)
                fieldType := baseVal.Type().Field(i)
                overrideFieldValue := overrideVal.Field(i)

                if fieldType.PkgPath != "" </span><span class="cov8" title="1">{
                        continue</span> // Unexported field -&gt; skip
                }

                <span class="cov8" title="1">if !result.Field(i).CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">opts.CurrentPath = concatPath(basePath, getJSONTag(fieldType))

                if fieldValue.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        // Handle pointer fields
                        if fieldValue.IsNil() &amp;&amp; overrideFieldValue.IsNil() </span><span class="cov0" title="0">{
                                result.Field(i).Set(reflect.Zero(fieldValue.Type()))
                        }</span> else<span class="cov8" title="1"> if fieldValue.IsNil() </span><span class="cov0" title="0">{
                                result.Field(i).Set(overrideFieldValue)
                        }</span> else<span class="cov8" title="1"> if overrideFieldValue.IsNil() </span><span class="cov0" title="0">{
                                result.Field(i).Set(fieldValue)
                        }</span> else<span class="cov8" title="1"> {
                                // Merge the dereferenced values
                                mergedValue, err := mergeRecursive(fieldValue.Elem(), overrideFieldValue.Elem(), opts)
                                if err != nil </span><span class="cov0" title="0">{
                                        return reflect.Value{}, err
                                }</span>
                                <span class="cov8" title="1">mergedPointer := reflect.New(fieldValue.Type().Elem())
                                mergedPointer.Elem().Set(mergedValue)
                                result.Field(i).Set(mergedPointer)</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Handle non-pointer fields
                        merged, err := mergeRecursive(fieldValue, overrideFieldValue, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return reflect.Value{}, err
                        }</span>
                        <span class="cov8" title="1">result.Field(i).Set(merged)</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// mergeMap merges two map values (non-timestamped case).
func mergeMap(baseVal, overrideVal reflect.Value, opts MergeObject) (reflect.Value, error) <span class="cov8" title="1">{
        if baseVal.IsNil() </span><span class="cov0" title="0">{
                notifyRecursive(overrideVal, model.MergeOperationAdd, opts)

                return overrideVal, nil
        }</span>

        <span class="cov8" title="1">basePath := opts.CurrentPath

        if overrideVal.IsNil() </span><span class="cov0" title="0">{
                switch opts.Mode </span>{
                case ClientIsMaster:<span class="cov0" title="0">
                        for _, key := range baseVal.MapKeys() </span><span class="cov0" title="0">{
                                opts.CurrentPath = concatPath(basePath, formatKey(key))

                                notifyRecursive(baseVal.MapIndex(key), model.MergeOperationRemove, opts)
                        }</span>

                        <span class="cov0" title="0">return overrideVal, nil</span>
                case ServerIsMaster:<span class="cov0" title="0">
                        for _, key := range baseVal.MapKeys() </span><span class="cov0" title="0">{
                                opts.CurrentPath = concatPath(basePath, formatKey(key))

                                notifyRecursive(baseVal.MapIndex(key), model.MergeOperationNotChanged, opts)
                        }</span>

                        <span class="cov0" title="0">return baseVal, nil</span>
                }
        }

        <span class="cov8" title="1">result := reflect.MakeMap(baseVal.Type())

        // Base keys
        baseKeys := make(map[string]reflect.Value, baseVal.Len())

        for _, key := range baseVal.MapKeys() </span><span class="cov8" title="1">{
                baseKeys[formatKey(key)] = key
        }</span>

        <span class="cov8" title="1">for _, key := range overrideVal.MapKeys() </span><span class="cov8" title="1">{
                overrideVal := overrideVal.MapIndex(key)
                baseValForKey := baseVal.MapIndex(key)

                opts.CurrentPath = concatPath(basePath, formatKey(key))

                if !baseValForKey.IsValid() </span><span class="cov8" title="1">{
                        result.SetMapIndex(key, overrideVal) // add

                        notifyRecursive(overrideVal, model.MergeOperationAdd, opts)

                        continue</span>
                }

                // Remove key from base
                <span class="cov8" title="1">delete(baseKeys, formatKey(key))

                // Merge recursively
                merged, err := mergeRecursive(baseValForKey, overrideVal, opts)

                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>

                <span class="cov8" title="1">result.SetMapIndex(key, merged)</span> // Already notified in (mergeRecursive)
        }

        // keys in base (but not in override)
        <span class="cov8" title="1">for k, v := range baseKeys </span><span class="cov8" title="1">{
                opts.CurrentPath = concatPath(basePath, k)

                if opts.Mode == ServerIsMaster </span><span class="cov8" title="1">{
                        result.SetMapIndex(v, baseVal.MapIndex(v)) // keep

                        notifyRecursive(baseVal.MapIndex(v), model.MergeOperationNotChanged, opts)
                }</span> else<span class="cov8" title="1"> /*ClientIsMaster*/ {
                        notifyRecursive(baseVal.MapIndex(v), model.MergeOperationRemove, opts)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func unwrapValueAndTimestamp(rv reflect.Value) (model.ValueAndTimestamp, bool) <span class="cov8" title="1">{
        // Must be a pointer or interface with non nil value
        if !rv.IsValid() || rv.Kind() == reflect.Invalid || (rv.Kind() == reflect.Ptr || rv.Kind() == reflect.Interface) &amp;&amp; rv.IsNil() </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Check for IdValueAndTimestamp first (which also implements ValueAndTimestamp)
        <span class="cov8" title="1">if idvt, ok := unwrapIdValueAndTimestamp(rv); ok </span><span class="cov8" title="1">{
                return idvt, true
        }</span>

        // Unwrap pointers and interfaces recursively
        <span class="cov8" title="1">rv = unwrapReflectValue(rv)

        if !rv.IsValid() </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Try to convert the value directly
        <span class="cov8" title="1">if vt, ok := toValueAndTimestamp(rv); ok </span><span class="cov0" title="0">{
                return vt, true
        }</span>

        <span class="cov8" title="1">if !rv.CanAddr() </span><span class="cov8" title="1">{
                copy := reflect.New(rv.Type())
                copy.Elem().Set(rv)
                rv = copy
        }</span> else<span class="cov8" title="1"> {
                rv = rv.Addr()
        }</span>

        // Attempt conversion on the copied addressable value
        <span class="cov8" title="1">if vt, ok := toValueAndTimestamp(rv); ok </span><span class="cov8" title="1">{
                return vt, true
        }</span>

        <span class="cov8" title="1">return nil, false</span>
}

// unwrapReflectValue unwraps pointers and interfaces recursively so it returns the
// first non-pointer/interface value.
func unwrapReflectValue(rv reflect.Value) reflect.Value <span class="cov8" title="1">{
        for rv.IsValid() &amp;&amp; (rv.Kind() == reflect.Ptr || rv.Kind() == reflect.Interface) </span><span class="cov8" title="1">{
                if rv.IsNil() </span><span class="cov0" title="0">{
                        return reflect.Value{}
                }</span>

                <span class="cov8" title="1">rv = rv.Elem()</span>
        }

        <span class="cov8" title="1">return rv</span>
}

// toValueAndTimestamp attempts to convert a reflect.Value to ValueAndTimestamp.
func toValueAndTimestamp(rv reflect.Value) (model.ValueAndTimestamp, bool) <span class="cov8" title="1">{
        //
        if rv.Kind() == reflect.Interface || rv.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if i, ok := rv.Interface().(model.ValueAndTimestamp); ok </span><span class="cov8" title="1">{
                        return i, true
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}

// isEmptyValue checks if a reflect.Value is valid or "the zero value" (len of zero).
func isEmptyValue(v reflect.Value) bool <span class="cov8" title="1">{
        if !v.IsValid() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.Array, reflect.Map, reflect.Slice, reflect.String:<span class="cov8" title="1">
                return v.Len() == 0</span>
        case reflect.Bool,
                reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
                reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
                reflect.Float32, reflect.Float64,
                reflect.Interface, reflect.Pointer:<span class="cov8" title="1">
                return v.IsZero()</span>
        }

        <span class="cov0" title="0">return false</span>
}

func concatPath(path, name string) string <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return path + "." + name</span>
}

// getJSONTag get the tag (name part only) from a struct field.
//
// If no _JSON_ field tag is present, the field name is returned.
func getJSONTag(field reflect.StructField) string <span class="cov8" title="1">{
        tag := field.Tag.Get("json")
        if tag == "" </span><span class="cov8" title="1">{
                return field.Name
        }</span>

        // If the tag is "-", ignore it
        <span class="cov8" title="1">if tag == "-" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // comma -&gt; ignore the rest
        <span class="cov8" title="1">idx := strings.Index(tag, ",")
        if idx != -1 </span><span class="cov0" title="0">{
                return tag[:idx]
        }</span>

        <span class="cov8" title="1">return tag</span>
}

// mergeSliceByPosition merges two slices based on their positions (original implementation)
func mergeSliceByPosition(baseVal, overrideVal reflect.Value, opts MergeObject) (reflect.Value, error) <span class="cov8" title="1">{
        baseLen := baseVal.Len()
        ovLen := overrideVal.Len()
        basePath := opts.CurrentPath

        // Merge each element up to the min of both lengths
        minLen := baseLen
        maxLen := ovLen
        if ovLen &lt; minLen </span><span class="cov8" title="1">{
                minLen = ovLen
                maxLen = baseLen
        }</span>

        // Create a new slice of the same type as baseVal
        <span class="cov8" title="1">result := reflect.MakeSlice(baseVal.Type(), 0, maxLen)

        for i := 0; i &lt; minLen; i++ </span><span class="cov8" title="1">{
                baseElem := baseVal.Index(i)
                ovElem := overrideVal.Index(i)

                opts.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)
                mergedElem, err := mergeRecursive(baseElem, ovElem, opts)

                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>

                <span class="cov8" title="1">result = reflect.Append(result, mergedElem)</span>
        }

        // new slice is longer -&gt; add extra elements in override
        <span class="cov8" title="1">if ovLen &gt; minLen </span><span class="cov8" title="1">{
                for i := minLen; i &lt; ovLen; i++ </span><span class="cov8" title="1">{
                        opts.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)
                        result = reflect.Append(result, overrideVal.Index(i))

                        notifyRecursive(overrideVal.Index(i), model.MergeOperationAdd, opts)
                }</span>
        }

        // old slice is longer -&gt; remove or keep
        <span class="cov8" title="1">if baseLen &gt; minLen </span><span class="cov8" title="1">{
                if opts.Mode == ServerIsMaster </span><span class="cov8" title="1">{
                        // ServerIsMaster -&gt; keep
                        for i := minLen; i &lt; baseLen; i++ </span><span class="cov8" title="1">{
                                opts.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)
                                result = reflect.Append(result, baseVal.Index(i))

                                notifyRecursive(baseVal.Index(i), model.MergeOperationNotChanged, opts)
                        }</span>
                } else<span class="cov8" title="1"> /*ClientIsMaster*/ {
                        for i := minLen; i &lt; baseLen; i++ </span><span class="cov8" title="1">{
                                opts.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)

                                notifyRecursive(baseVal.Index(i), model.MergeOperationRemove, opts)
                        }</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

// unwrapIdValueAndTimestamp attempts to convert a reflect.Value to IdValueAndTimestamp
func unwrapIdValueAndTimestamp(rv reflect.Value) (model.IdValueAndTimestamp, bool) <span class="cov8" title="1">{
        // Must be a pointer or interface with non nil value
        if !rv.IsValid() || rv.Kind() == reflect.Invalid || (rv.Kind() == reflect.Ptr || rv.Kind() == reflect.Interface) &amp;&amp; rv.IsNil() </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Unwrap pointers and interfaces recursively
        <span class="cov8" title="1">origRv := rv
        rv = unwrapReflectValue(rv)

        if !rv.IsValid() </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // Try direct conversion first
        <span class="cov8" title="1">if idvt, ok := origRv.Interface().(model.IdValueAndTimestamp); ok </span><span class="cov8" title="1">{
                return idvt, true
        }</span>

        // If not addressable, make a copy
        <span class="cov8" title="1">if !rv.CanAddr() </span><span class="cov8" title="1">{
                copy := reflect.New(rv.Type())
                copy.Elem().Set(rv)
                rv = copy
        }</span> else<span class="cov8" title="1"> {
                rv = rv.Addr()
        }</span>

        // Try conversion on the addressable value
        <span class="cov8" title="1">if idvt, ok := rv.Interface().(model.IdValueAndTimestamp); ok </span><span class="cov8" title="1">{
                return idvt, true
        }</span>

        <span class="cov8" title="1">return nil, false</span>
}

// mergeSliceByID merges two slices by matching elements with the same ID
func mergeSliceByID(baseVal, overrideVal reflect.Value, opts MergeObject) (reflect.Value, error) <span class="cov8" title="1">{
        baseLen := baseVal.Len()
        ovLen := overrideVal.Len()
        basePath := opts.CurrentPath

        // Create a new slice of the same type as baseVal
        result := reflect.MakeSlice(baseVal.Type(), 0, baseLen+ovLen)

        // Maps to track elements by ID
        baseMap := make(map[string]int)     // ID -&gt; index in baseVal
        overrideMap := make(map[string]int) // ID -&gt; index in overrideVal
        processed := make(map[string]bool)  // IDs that have been processed

        // First, try to extract IDs from base elements
        var canUseIDs bool = true
        for i := 0; i &lt; baseLen; i++ </span><span class="cov8" title="1">{
                elem := baseVal.Index(i)
                if idvt, ok := unwrapIdValueAndTimestamp(elem); ok </span><span class="cov8" title="1">{
                        id := idvt.GetID()
                        baseMap[id] = i
                }</span> else<span class="cov8" title="1"> {
                        // If any element doesn't implement IdValueAndTimestamp, fall back to positional merge
                        canUseIDs = false
                        break</span>
                }
        }

        // If we can't use IDs, fall back to positional merge
        <span class="cov8" title="1">if !canUseIDs </span><span class="cov8" title="1">{
                return mergeSliceByPosition(baseVal, overrideVal, opts)
        }</span>

        // Extract IDs from override elements
        <span class="cov8" title="1">for i := 0; i &lt; ovLen; i++ </span><span class="cov8" title="1">{
                elem := overrideVal.Index(i)
                if idvt, ok := unwrapIdValueAndTimestamp(elem); ok </span><span class="cov8" title="1">{
                        id := idvt.GetID()
                        overrideMap[id] = i
                }</span> else<span class="cov0" title="0"> {
                        // If any element doesn't implement IdValueAndTimestamp, fall back to positional merge
                        return mergeSliceByPosition(baseVal, overrideVal, opts)
                }</span>
        }

        // Process elements that exist in both slices
        <span class="cov8" title="1">for id, baseIdx := range baseMap </span><span class="cov8" title="1">{
                baseElem := baseVal.Index(baseIdx)

                if overrideIdx, exists := overrideMap[id]; exists </span><span class="cov8" title="1">{
                        // Element exists in both - merge them
                        overrideElem := overrideVal.Index(overrideIdx)
                        opts.CurrentPath = fmt.Sprintf("%s.%s", basePath, id)

                        mergedElem, err := mergeRecursive(baseElem, overrideElem, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return reflect.Value{}, err
                        }</span>

                        <span class="cov8" title="1">result = reflect.Append(result, mergedElem)
                        processed[id] = true</span>
                } else<span class="cov8" title="1"> if opts.Mode == ServerIsMaster </span><span class="cov8" title="1">{
                        // Element only in base and server is master - keep it
                        opts.CurrentPath = fmt.Sprintf("%s.%s", basePath, id)
                        result = reflect.Append(result, baseElem)
                        notifyRecursive(baseElem, model.MergeOperationNotChanged, opts)
                }</span> else<span class="cov8" title="1"> {
                        // Element only in base and client is master - remove it
                        opts.CurrentPath = fmt.Sprintf("%s.%s", basePath, id)
                        notifyRecursive(baseElem, model.MergeOperationRemove, opts)
                }</span>
        }

        // Add elements that only exist in override
        <span class="cov8" title="1">for id, overrideIdx := range overrideMap </span><span class="cov8" title="1">{
                if !processed[id] </span><span class="cov8" title="1">{
                        // Element only in override - add it
                        overrideElem := overrideVal.Index(overrideIdx)
                        opts.CurrentPath = fmt.Sprintf("%s.%s", basePath, id)
                        result = reflect.Append(result, overrideElem)
                        notifyRecursive(overrideElem, model.MergeOperationAdd, opts)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package merge

import (
        "fmt"
        "reflect"
        "time"

        "github.com/mariotoffia/godeviceshadow/model"
)

// notifyRecursive will recursively notify the leafs of the _op_ operation.
//
// NOTE: _op_ may only be `model.MergeOperationAdd`, `model.MergeOperationRemove`,  and
// `model.MergeOperationNotChanged` nothing else.
func notifyRecursive(val reflect.Value, op model.MergeOperation, obj MergeObject) <span class="cov8" title="1">{
        if len(obj.Loggers) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if vt, ok := unwrapValueAndTimestamp(val); ok </span><span class="cov8" title="1">{
                switch op </span>{
                case model.MergeOperationAdd:<span class="cov8" title="1">
                        obj.Loggers.NotifyManaged(obj.CurrentPath, op, nil, vt, time.Time{}, vt.GetTimestamp())</span>
                case model.MergeOperationRemove:<span class="cov8" title="1">
                        obj.Loggers.NotifyManaged(obj.CurrentPath, op, vt, nil, vt.GetTimestamp(), time.Time{})</span>
                case model.MergeOperationNotChanged:<span class="cov0" title="0">
                        obj.Loggers.NotifyManaged(obj.CurrentPath, op, vt, vt, vt.GetTimestamp(), vt.GetTimestamp())</span>
                }

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">val = unwrapReflectValue(val)
        basePath := obj.CurrentPath

        switch val.Kind() </span>{
        case reflect.Struct:<span class="cov8" title="1">
                for i := 0; i &lt; val.NumField(); i++ </span><span class="cov8" title="1">{
                        field := val.Type().Field(i)

                        if field.PkgPath != "" </span><span class="cov0" title="0">{
                                continue</span> // Unexported field -&gt; skip
                        }

                        <span class="cov8" title="1">tag := getJSONTag(field)

                        if tag == "" </span><span class="cov0" title="0">{
                                continue</span> // No tag -&gt; skip
                        }

                        <span class="cov8" title="1">obj.CurrentPath = concatPath(basePath, tag)

                        notifyRecursive(val.Field(i), op, obj)</span>
                }
        case reflect.Map:<span class="cov0" title="0">
                for _, key := range val.MapKeys() </span><span class="cov0" title="0">{
                        obj.CurrentPath = concatPath(basePath, formatKey(key))

                        notifyRecursive(val.MapIndex(key), op, obj)
                }</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                for i := 0; i &lt; val.Len(); i++ </span><span class="cov0" title="0">{
                        obj.CurrentPath = fmt.Sprintf("%s.%d", basePath, i)

                        notifyRecursive(val.Index(i), op, obj)
                }</span>
        default:<span class="cov8" title="1">
                if !val.IsValid() </span><span class="cov0" title="0">{
                        return // Do not notify nil values
                }</span>

                <span class="cov8" title="1">switch op </span>{
                case model.MergeOperationAdd:<span class="cov8" title="1">
                        obj.Loggers.NotifyPlain(obj.CurrentPath, op, nil, val.Interface())</span>
                case model.MergeOperationRemove:<span class="cov8" title="1">
                        obj.Loggers.NotifyPlain(obj.CurrentPath, op, val.Interface(), nil)</span>
                case model.MergeOperationNotChanged:<span class="cov0" title="0">
                        obj.Loggers.NotifyPlain(obj.CurrentPath, op, val.Interface(), val.Interface())</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package merge

import (
        "fmt"
        "reflect"
        "strings"
)

func formatKey(key reflect.Value) string <span class="cov8" title="1">{
        if !key.IsValid() </span><span class="cov0" title="0">{
                return "&lt;invalid&gt;"
        }</span>

        <span class="cov8" title="1">switch key.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return key.String()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return fmt.Sprintf("%d", key.Int())</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", key.Uint())</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return fmt.Sprintf("%f", key.Float())</span>
        case reflect.Struct:<span class="cov8" title="1">
                var fields []string
                for i := 0; i &lt; key.NumField(); i++ </span><span class="cov8" title="1">{
                        field := key.Type().Field(i)
                        value := key.Field(i).Interface()
                        fields = append(fields, fmt.Sprintf("%s:%v", field.Name, value))
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("{%s}", strings.Join(fields, ","))</span>
        case reflect.Interface:<span class="cov8" title="1">
                // Recursively handle the underlying type of the interface
                return formatKey(key.Elem())</span>
        case reflect.Ptr:<span class="cov8" title="1">
                // Handle pointer by dereferencing if not nil
                if key.IsNil() </span><span class="cov0" title="0">{
                        return "&lt;nil&gt;"
                }</span>
                <span class="cov8" title="1">return formatKey(key.Elem())</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("&lt;unsupported key type: %s&gt;", key.Type())</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
