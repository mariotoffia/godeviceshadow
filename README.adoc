= Go Device Shadow (godeviceshadow)
This is an implementation of a device shadow storage and notification for DynamoDB and SQS/SNS. It is pluggable for other storage/notifications.

== Introduction

CAUTION: This is work in progress and is in design stages - do not use it. This statement is removed when this library have a alpha status.

This is a somewhat emulation of the existing IoT Core Device Shadow. However, it separates the _Reported_ and _Desired_ states into two different sort keys to allow for more data and better querying.

The partition key is the "name" of the device shadow and hence, it is possible to do advanced naming e.g. _My House#Basement#Lightning Controller_ as a _PK_. The _SK_(s) are handled by this library.

The storage is pluggable, but it comes with a DynamoDB and in-memory implementation out of the box.

.Example Use Embedded and In Memory 
[source,go]
----
ctx := context.Background()
now := time.Now()

mgr := manager.New(). // <1>
  WithPersistence(mempersistence.New()). // <2>
  WithSeparation(persistencemodel.SeparateModels). // <3>
  WithReportedLoggers(changelogger.New()). // <4>
  WithTypeRegistryResolver(
    types.NewRegistry().RegisterResolver(
      model.NewResolveFunc(func(id, name string) (model.TypeEntry, bool) {
        if name == "homeHub" { // <5>
          return model.TypeEntry{
            Name: "homeHub", Model: reflect.TypeOf(TestModel{}),
          }, true
        }

        return model.TypeEntry{}, false
      }),
    ),
  ).
  Build()

res := mgr.Report(ctx, manager.ReportOperation{ // <6>
  ClientID: "myClient",
  Version:  0, // <7>
  Model: TestModel{
    TimeZone: tz,
    Sensors: map[string]Sensor{
      "temp": {Value: 23.4, TimeStamp: now},
    },
  },
  ID: persistencemodel.ModelIndependentPersistenceID{ID: "device123", Name: "homeHub"},
})

chl := changelogger.FindLogger(res[0].MergeLoggers) // <8>
sns, err := chl.ManagedFromPath(`Sensors\..*`)
sensors := sns.All()

fmt.Printf("%s: %s", sensors[0].Path, sensors[0].NewValue.GetTimestamp().Format(time.RFC3339)) // <9>
----
<1> Use builder to create a new manager.
<2> Use in-memory persistence. Swap this e.g. for _DynamoDB_ persistence via `dynamodbpersistence.New(...)`.
<3> Separate the model persistence by default - can be overridden on each write operation.
<4> Use the change logger to log changes both managed and plain values for post examination. This registers the `New` function so a new logger is always created on each report.
<5> Simple resolver that only resolves the `homeHub` model.
<6> Report the model and thereby merge with model in the persistence and ensure any desired acknowledgements are done. In this case nothing is persisted so it will create a new model and merge it.
<7> The version is 0 and will be incremented by the system. If using zero it will always use the latest version to merge with. If explicit version is use, it will only merge if the version is the same (and then increment the version).
<8> Find the change logger and extract the managed values from the path `Sensors\..*` (_Regular Expression_).
<9> Outputs e.q. _Sensors.temp: 2025-01-22T13:22:26+01:00_

== TIP ðŸ’¡: View All Examples
To view all examples, visit the https://github.com/mariotoffia/godeviceshadow/tree/main/examples[Examples] directory.

== Core Concepts

This is a model runtime and not a plain _JSON_ runtime, thus it handles golang models. The main interface is the `model.ValueAndTimestamp` of which it uses to discover variables and handle them.

ValueAndTimestamp Interface
[source,go]
----
// ValueAndTimestamp is the interface that fields must implement if they
// support timestamp-based merging.
type ValueAndTimestamp interface {
  // GetTimestamp will return the timestamp associated with the value. This is
  // used to determine which value is newer when a merge is commenced.
  GetTimestamp() time.Time
  // GetValue will return the value that the timestamp is associated with.
  //
  // If multiple values, the instance itself is the value and this method
  // will return the _"default"_ value. If the value is a map[string]any
  // it will return all values where the key is the name of the value.
  //
  // The latter gives the caller a way of knowing what values are relevant
  // to e.g. log instead of iterate the whole struct.
  GetValue() any
}
----

Those may be anywhere in a structs, maps etc. The system will iterate all and handle all such elements.

.Example "DeviceShadow" Model
[source,go]
----
type HomeTemperatureHub struct {
  *MetaInfo      `json:"meta,omitempty"`
  ClimateSensors *ClimateSensors            `json:"climate,omitempty"`
  IndoorTempSP   *IndoorTemperatureSetPoint `json:"indoor_temp_sp,omitempty"` // Important omitempty when used in desired
}

type MetaInfo struct {
  TimeZone string `json:"tz,omitempty"`
  Owner    string `json:"owner,omitempty"`
}

type Direction string

const (
  DirectionNorth Direction = "north"
  DirectionSouth Direction = "south"
  DirectionEast  Direction = "east"
  DirectionWest  Direction = "west"
)

type IndoorTemperatureSensor struct {
  Floor       int       `json:"floor"`
  Direction   Direction `json:"direction"`
  Temperature float64   `json:"t"`
  Humidity    float64   `json:"h"`
  UpdatedAt   time.Time `json:"ts"`
}

func (idt *IndoorTemperatureSensor) GetTimestamp() time.Time {
  return idt.UpdatedAt
}

func (idt *IndoorTemperatureSensor) GetValue() any {
  return map[string]any{ // <1>
    "floor":       idt.Floor,
    "direction":   idt.Direction,
    "temperature": idt.Temperature,
    "humidity":    idt.Humidity,
  }
}

type OutdoorTemperatureSensor struct {
  Direction   Direction `json:"direction"`
  Temperature float64   `json:"t"`
  Humidity    float64   `json:"h"`
  UpdatedAt   time.Time `json:"ts"`
}

func (ots *OutdoorTemperatureSensor) GetTimestamp() time.Time {
  return ots.UpdatedAt // <2>
}

func (ots *OutdoorTemperatureSensor) GetValue() any {
  return map[string]any{
    "direction":   ots.Direction,
    "temperature": ots.Temperature,
    "humidity":    ots.Humidity,
  }
}

type IndoorTemperatureSetPoint struct {
  SetPoint  float64   `json:"sp"`
  UpdatedAt time.Time `json:"ts"`
}

func (sp *IndoorTemperatureSetPoint) GetTimestamp() time.Time {
  return sp.UpdatedAt
}

func (sp *IndoorTemperatureSetPoint) GetValue() any {
  return sp.SetPoint
}

type ClimateSensors struct {
  Outdoor map[string]OutdoorTemperatureSensor `json:"outdoor,omitempty"`
  Indoor  map[string]IndoorTemperatureSensor  `json:"indoor,omitempty"`
}
----
<1> When map, it will check all values to determine if any value change has occurred, otherwise just return a plain value.
<2> This is the timestamp it will use to determine if the value is newer or older (or same).

== Device Shadow Layout

The device shadow is rather alike the IoT Core Device Shadow but with a few differences. It can split the _Reported_ and _Desired_ states into two different sort keys to allow for more data and better querying. It will not provide with any diff inside the shadow itself. Instead this is reported when a change has been made to the reported/desired shadow as both old, new and diff.

=== Loggers

There is a pluggable logger architecture to allow for multiple loggers to participate in report diff or desired diffs. This allows for e.g. output the changes or to store added/changed values in _Amazon Aurora DSQL_, _Time-Stream_ or similar storage. Loggers may interact with "plain" elements such as simple string or the "managed" (those who implements the `model.ValueAndTimestamp` interface).

=== Notifications

When a shadow is updated, a notification can be sent to listeners. This is done by the notification implementation. 

Each target registration specifies what type of plugin (e.g. SQS), attributes such as the queue name, topic name, etc.

In addition the attributes specifies what type of events to listen for:
* Report, Desired or Both
* Regexp for PK and SK combined with a'#' separator.
* Old, New, Diff (or any combination of these)

The registrations are stored as _JSON_ with the event lambda itself (for dynamodb stream). 


== Client SDK

=== Deviations

There are many deviations from the IoT Core Device Shadow. One of the most prominent is the notion of the device shadow _MODEL_. It will be replaced in full every time a write is done.

=== Timestamps

The timestamps on the items in the device shadow is completely different than for the IoT Core Device Shadow. The timestamps a _RFC3339_ timestamp (but since it uses the interface, they may be anything). The _RFC3339_ timestamp may be used when the tz may differ between the different items.

The value and timestamp is clumped together and is accessed via `ValueAndTimestamp` _interface_. The underlying struct may be anything. Each item that you want to make the client handle timestamps for must implement this interface.

.Example Model
[source,go]
----
type SensorValue struct {
  ValueAndTimestamp
  Timestamp time.Time `json:"timestamp"` // <1>
  Value any `json:"value"` // <2>
}

type Building struct {
  Controller Controller `json:"controller"`
}

type Controller struct {
  ID string `json:"id"`
  Serial string `json:"serial"`
  Brand string `json:"brand,omitempty"`
  Circuits map[int]Circuit `json:"circuits,omitempty"`
}

type Circuit struct {
   Senors map[string]SensorValue `json:"sensors,omitempty"` // <3>
}
----
<1> This is the timestamp that the sensor value was read for this example, it is possible to have many different types as long as it implements the `ValueAndTimestamp` interface.
<2> For this sensor we decided the use _RFC3339_ timestamp for user readability (not efficient though). If unix timestamp use `UnixTimestamp32` or for (64 bit `UnixTimestamp64` nano resolution) instead.
<3> Here all sensor values are stored as a map with the sensor name as the key and the value as the value. The value is a struct that implements the `ValueAndTimestamp` interface. The system only handles timestamps for a certain value and ignores the rest.

=== Creating or Updating the Device Shadow
When writing to the device shadow, for example _Report_, the _SDK_ will read the whole document and marshal it to the registered model. For example `Building` it will iterate all the fields and check if they implement the `ValueAndTimestamp` interface. If they do, it will use it to check if the client model is newer than the device shadow model. If it is, the client model value will be kept, if older, the device shadow model value will be copied to the client model.

If any field is missing in the client model but present in the shadow model, it will be added to the client model. If any field is present in the client model but not in the shadow model, it will be kept (se _Deleting an Element_ for the options).

When done it will write the loaded it back conditionally on version and increment the version (atomically). This is done with an updated timestamp of `time.Now.UTC().UnixNano()`. If the client supplied a `ClientToken` string, it will be added to the shadow as well.

On conflict, the client will read the shadow again and redo the merge and write it back again. After _n_ times it will give up and return an conflict error.

=== Deleting an Element

When iterating merging the structures there are two modes:  _ClientIsMaster_ and  _ServerIsMaster_.

When _ClientIsMaster_ it will just check elements that are timestamped and exists on both models. If the server model value is newer, the value will be copied to the client model. Otherwise the client model will be kept as is.

If the _ServerIsMaster_ mode it will not allow the client to delete any property only, add, update or keep values are possible.

In both modes, all values that do not implement `ValueAndTimestamp` are just used as is on the client model to write the device shadow (i.e. always overwritten without any timestamp handling).

When _ServerIsMaster_ it is not possible to delete elements only add and updates are possible from the client model.

=== Desired State

This is a separate sort key and must match a _Reported_ sort key name. This is to denote the desired state and when the client wants to report a state it may also include that the _SDK_ shall load the desired state and clear it when the desired state value are the same as reported.

In this case it will need to do this in a transaction since it is two different sort keys. For DynamoDB this is done using the transaction _API_.

It is possible for a client to state that it should ignore the desired state and only report the reported state. This is done by setting the _IgnoreDesiredState_ mode instead of the default _UseDesiredState_ mode when doing reporting.